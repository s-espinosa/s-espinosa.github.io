<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <title>Sal Espinosa</title>
  <link rel="shortcut icon" type="image/png" href="/logo-16x16.png">
  <link rel="stylesheet" type="text/css" href="../../../../css/reset.css">
  <link rel="stylesheet" type="text/css" href="../../../../css/main.css">
  <link rel="stylesheet" type="text/css" href="../../../../css/code.css">
</head>


  <body>

    <header class="wrapper">
  <h1><a href="../../../../">Sal Espinosa</a></h1>
  <nav>
    <a href="../../../../">home</a>
    <a href="../../../../pages/posts.html">posts</a>
    <a href="../../../../pages/github.html">github</a>
    <a href="../../../../pages/media.html">media</a>
    <a href="../../../../pages/music.html">music</a>
  </nav>
</header>


    <main class="wrapper">
      <img src="../../../../image/tests.jpg">

      <h2>Look at all those passing tests.</h2>

      <p>Recently, a cohort member asked me what my approach to testing Turing’s <a href="https://github.com/turingschool/curriculum/blob/master/source/projects/black_thursday.markdown">Black Thursday</a> project had been. This project has been filling my days (and sometimes my nights), so I suppose I shouldn’t have been surprised when I realized I had a lot to say on the subject. I’m not altogether convinced I have a full handle on the terminology (<a href="http://martinfowler.com/articles/mocksArentStubs.html">stubs? fixtures? mocks? doubles?</a>), but here’s what <a href="https://github.com/kristindiannefoss">Kris</a> (my partner on this project) and I came up with this time around.</p>

<h3 id="the-assignment">The Assignment</h3>

<p>At a high level, the assignment was as follows: we were given 6 csv’s, filled to the brim with data, and asked to link them, analyze them, and report on them. The project specification expects that we’ll have both classes for individual objects (the items, customers, merchants, etc.), and classes to hold them (repositories). We wanted to make sure that our testing was effective, comprehensive, and efficient. <a href="https://github.com/worace">Horace</a> warned us early on that tests that took a long time to run would break our flow, and ultimately hurt our development process. We wanted to make sure that we caught all of the edge cases we could think of, while at the same time not having to run through all of the actual data every time we ran our tests.</p>

<h3 id="items-merchants-etc">Items, Merchants, Etc.</h3>

<p>For our low level classes (merchant, item, etc.) we used a setup method to hold a hash containing info we would expect from a single line of CSV.</p>

<p><code class="highlighter-rouge">ruby
def setup
  @invoice = Invoice.new({:id          =&gt; 6,
                          :customer_id =&gt; 7,
                          :merchant_id =&gt; 8,
                          :status      =&gt; "pending",
                          :created_at  =&gt; "2014-03-15",
                          :updated_at  =&gt; "2014-03-15",
  })
end
</code></p>

<p>The main benefit of this approach is that it’s pretty easy to look to the top of the test and see what exactly we expect to be in a given Invoice instance: if the id is 6 in the hash, then the test pretty much writes itself.</p>

<p><code class="highlighter-rouge">ruby
def test_it_has_an_id
  assert_equal 6, @invoice.id
end
</code></p>

<p>We used examples from the spec when available. More info <a href="http://chriskottom.com/blog/2014/10/4-fantastic-ways-to-set-up-state-in-minitest/">here</a> on how to create a setup method that will run prior to your tests, though in retrospect I realize that this runs before <em>each</em> test. I’d rather have it run once before all the tests.</p>

<h3 id="repos">Repos</h3>

<p>For our repos, we took more or less the same approach, but in the setup method we’ve been creating a few instances of the thing the repo is supposed to hold (some items, merchants, or whatever), and then feeding those into the repo using new.</p>

<p>```ruby
def setup
  @invoice1 = Invoice.new({id: 1,
                           customer_id: 1,
                           merchant_id: 12335938,
                           status: “pending”,
                           created_at: “2009-02-07”,
                           updated_at: “2014-03-15”})
  @invoice2 = Invoice.new({id: 2,
                           customer_id: 1,
                           merchant_id: 12334753,
                           status: “shipped”,
                           created_at: “2009-02-07”,
                           updated_at: “2014-03-15”})
  @invoice3 = Invoice.new({id: 3,
                           customer_id: 2,
                           merchant_id: 12334753,
                           status: “pending”,
                           created_at: “2009-02-07”,
                           updated_at: “2014-03-15”})</p>

<p>@invoices = [invoice1, invoice2, invoice3]
  @se       = SalesEngine.new</p>

<p>@ir = InvoiceRepository.new(@invoices, se)
end
```</p>

<p>Looking at a few of our tests it seemed that the repos generally took an array in their initialize, so it just became a matter of creating three or four instances of whatever the repo is supposed to hold, putting those into an array, and then passing that array to the repo. That put us in pretty much the same place as we were for our Items/Merchants testing, and we could just look to the top of the test to see what we were expecting.</p>

<h3 id="sales-enginesales-analyst">Sales Engine/Sales Analyst</h3>

<p>For Sales Engine and Sales Analyst we wanted to use actual data, but not all of it. We took the data and cut out some chunks (usually around 25 rows or so, sometimes more) that we could use to do our testing and put those into a test_data folder in our test folder. We then initialize SE and/or SA with references to the test data instead of the full data set.</p>

<p><code class="highlighter-rouge">ruby
def setup
  @se = SalesEngine.from_csv({
    :items         =&gt; "./test/test_data/items_stub.csv",
    :merchants     =&gt; "./test/test_data/merchants_stub.csv",
    :invoices      =&gt; "./test/test_data/invoices_stub.csv",
    :invoice_items =&gt; "./test/test_data/invoice_items_stub.csv",
    :transactions  =&gt; "./test/test_data/transactions_stub.csv",
    :customers     =&gt; "./test/test_data/customers_stub.csv"
  })
end
</code></p>

<p>This became a little tricky when Sales Analyst started to look for outliers that are two above the standard deviation. Pretty consistently we had to go in to tweak the data so that, for example, we had enough Sunday purchases to make sure that we didnt get an empty array when trying to find outliers.</p>

<h3 id="sales-enginesales-analyst-part-ii">Sales Engine/Sales Analyst Part II</h3>

<p>Iteration 3 had us building and analyzing more relationships between the data. It seemed like we were getting nonsense results because the real data that we pulled for Merchants or Invoices didn’t necessarily have any relationship to other real data that we pulled for Transactions or ItemInvoices (which makes sense since we were just going in and pulling random chunks of data). Here we decided to go with completely synthetic data, which Kris was able to create for us. In essence we were trying to craft small data sets that had straightforward relationships so that we could pretty quickly determine expected outcomes for our tests. This way we would know that if we had an InvoiceItem that had an invoice_id of 2, then we would also have an Invoice in our InvoiceRepo with an id of 2 to go along with it.</p>

<h3 id="full-data">Full Data</h3>

<p>Ultimately that synethetic data only got us part of the way there. I’m pretty convinced that in a real world situation we would be able to have some deeper level discussions to determine the expected relationships between these pieces and design our data accordingly (this could be a silly, silly dream!). Unfortunately, in our case we were learning about the data and its relationships at the same time we were designing our tests. We built synthetic data that made sense at one point in the process, then found ourselves having to change it based on a deeper understanding that we accrued later. This of course broke all of our already established tests. As we started to see this more often, we decided that using the actual data would help us avoid some of these challenges. As Horace warned, we ended up dreading the tests a little, since we knew they would take some time to run. Given more time, I believe we could establish synthetic data that reflected the complexities of the actual data with fewer lines, but with the project due, we made what I think is probably an appropriate compromise. We still used our synthetic data where possible, and hit the real data as needed, and I don’t even feel that bad about it.</p>

<p>Maybe just a little.</p>

<p>Listen, I’m not redoing my tests now, okay? That said, I think next time we’ll likely push synthetic data earlier, and try to get a more thorough understanding of the relationships/shape of the project. This should help to keep us from having to reconfigure the data and keep the testing cycle relatively painless. If nothing else this project taught me the value of being able to cycle through your tests and continue coding without having to wait for tests to pass. I promise to do better next time.</p>


    </main>
  </body>
</html>
