<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sal Espinosa</title>
    <description></description>
    <link>http://s-espinosa.github.io/</link>
    <atom:link href="http://s-espinosa.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 29 Apr 2016 07:24:08 -0600</pubDate>
    <lastBuildDate>Fri, 29 Apr 2016 07:24:08 -0600</lastBuildDate>
    <generator>Jekyll v3.1.0</generator>
      <item>
        <title>Towards an Agile User Experience</title>
        <description>&lt;p&gt;I would totally link you to Jeremy Fish’s Twitter profile, except for everyone on the internet hates him and he deleted his twitter account. For some background, Fish was one of the subjects of the documentary Indie Game, which showed him creating the game Fez. It’s a beautiful game. It looks like it was a pain to develop. It was a tortured process, and watching Fish move through it was pretty incredible. That said, his reputation on the internet is as one of kind of a jerk and/or baby. The video below will give you some idea of why.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/yKUGwlFJAHw&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;If you didn’t bother to watch the movie, Fish basically talks about why he doesn’t like Japanese video games these days. He gets some help, and one of the other members of the panel talks about the difference between this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../image/itsdangerous.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../image/navi.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Which is fine as far as it goes. When people are playing video games it makes sense that you might not want to have all the answers given to you. You might be looking for a challenge. You might enjoy banging your head on a wall. The new iterations of some video games give a lot more clues as to what comes next, and they probably don’t scratch that itch.&lt;/p&gt;

&lt;p&gt;But I watched this video and it made me think of a different problem: instructions. The new Zelda games have perfected how to give a user instructions. All those things of the things that Fish and Co. hate about those new Zelda games have been iterated to make sure that people actually get the point, and know how to get to the next level/challenge.&lt;/p&gt;

&lt;p&gt;Meanwhile, web applications tend to either leave out instructions or have instructions that look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../image/facebook_instructions.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So what am I getting at? What can we learn from video games as we start to think about how to provide instructions to our users? I have three main takeaways.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) Let users level up.&lt;/strong&gt; The first and most important thing that I think video games have to offer is that they offer users value immediately, teach them things, and then also let them see more of the game over time. They have a way of introducing you to features just as you’re getting to the point that you’re ready for them. If you’re in the midst of designing something ask yourself, “is there a minimum use case for our users? What’s the absolute minimum that someone could use and actually find valuable?”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) Provide inline instructions.&lt;/strong&gt; When’s the last time you opened a video game with a manual? They’ve gone the way of the dinosaur. Don’t ask your users to completely break out of your application to view instructions or tutorials. Offer them hints and tips as they use it, when they’re ready. One app that does a wonderful job of doing this is the TraktorDJ iPhone app.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../image/traktor_inst.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) Don’t bother your users.&lt;/strong&gt; On the other hand, there’s a limit. Navi in the new Zelda games serves as a navigator who’s constantly reminding you if you’re going the wrong way. She chirps at you (“Hey! Listen!”), and flies around to try to remind you of the task at hand. That’s fine, but it kind of reminds me of the Microsoft paperclip.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../image/clippy.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This guy was just always getting in the way. It’s shockingly difficult to find an image of him that’s not been somehow turned into a joke about how awful he was. Here’s another look at the Traktor iPhone app.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../image/bothering.PNG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, that little button with a badge up in the right hand corner bothers me. It makes me want to learn more. It’s very much like a video game level that’s taunting me with the fact that I haven’t yet finished it. On the other hand, that’s something that I blame almost entirely on my own neuroses, and not at all on the application. Whether or not that’s fair is neither here nor there. I’m not annoyed at the app for trying to help me learn more about how to use it.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Apr 2016 10:01:46 -0600</pubDate>
        <link>http://s-espinosa.github.io/ui/2016/04/28/why-not-simple.html</link>
        <guid isPermaLink="true">http://s-espinosa.github.io/ui/2016/04/28/why-not-simple.html</guid>
        

        <category>UI</category>

      </item>

      <item>
        <title>Look at all those passing tests.</title>
        <description>&lt;p&gt;Recently, a cohort member asked me what my approach to testing Turing’s &lt;a href=&quot;https://github.com/turingschool/curriculum/blob/master/source/projects/black_thursday.markdown&quot;&gt;Black Thursday&lt;/a&gt; project had been. This project has been filling my days (and sometimes my nights), so I suppose I shouldn’t have been surprised when I realized I had a lot to say on the subject. I’m not altogether convinced I have a full handle on the terminology (&lt;a href=&quot;http://martinfowler.com/articles/mocksArentStubs.html&quot;&gt;stubs? fixtures? mocks? doubles?&lt;/a&gt;), but here’s what &lt;a href=&quot;https://github.com/kristindiannefoss&quot;&gt;Kris&lt;/a&gt; (my partner on this project) and I came up with this time around.&lt;/p&gt;

&lt;h3 id=&quot;the-assignment&quot;&gt;The Assignment&lt;/h3&gt;

&lt;p&gt;At a high level, the assignment was as follows: we were given 6 csv’s, filled to the brim with data, and asked to link them, analyze them, and report on them. The project specification expects that we’ll have both classes for individual objects (the items, customers, merchants, etc.), and classes to hold them (repositories). We wanted to make sure that our testing was effective, comprehensive, and efficient. &lt;a href=&quot;https://github.com/worace&quot;&gt;Horace&lt;/a&gt; warned us early on that tests that took a long time to run would break our flow, and ultimately hurt our development process. We wanted to make sure that we caught all of the edge cases we could think of, while at the same time not having to run through all of the actual data every time we ran our tests.&lt;/p&gt;

&lt;h3 id=&quot;items-merchants-etc&quot;&gt;Items, Merchants, Etc.&lt;/h3&gt;

&lt;p&gt;For our low level classes (merchant, item, etc.) we used a setup method to hold a hash containing info we would expect from a single line of CSV.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby
def setup
  @invoice = Invoice.new({:id          =&amp;gt; 6,
                          :customer_id =&amp;gt; 7,
                          :merchant_id =&amp;gt; 8,
                          :status      =&amp;gt; &quot;pending&quot;,
                          :created_at  =&amp;gt; &quot;2014-03-15&quot;,
                          :updated_at  =&amp;gt; &quot;2014-03-15&quot;,
  })
end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The main benefit of this approach is that it’s pretty easy to look to the top of the test and see what exactly we expect to be in a given Invoice instance: if the id is 6 in the hash, then the test pretty much writes itself.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby
def test_it_has_an_id
  assert_equal 6, @invoice.id
end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We used examples from the spec when available. More info &lt;a href=&quot;http://chriskottom.com/blog/2014/10/4-fantastic-ways-to-set-up-state-in-minitest/&quot;&gt;here&lt;/a&gt; on how to create a setup method that will run prior to your tests, though in retrospect I realize that this runs before &lt;em&gt;each&lt;/em&gt; test. I’d rather have it run once before all the tests.&lt;/p&gt;

&lt;h3 id=&quot;repos&quot;&gt;Repos&lt;/h3&gt;

&lt;p&gt;For our repos, we took more or less the same approach, but in the setup method we’ve been creating a few instances of the thing the repo is supposed to hold (some items, merchants, or whatever), and then feeding those into the repo using new.&lt;/p&gt;

&lt;p&gt;```ruby
def setup
  @invoice1 = Invoice.new({id: 1,
                           customer_id: 1,
                           merchant_id: 12335938,
                           status: “pending”,
                           created_at: “2009-02-07”,
                           updated_at: “2014-03-15”})
  @invoice2 = Invoice.new({id: 2,
                           customer_id: 1,
                           merchant_id: 12334753,
                           status: “shipped”,
                           created_at: “2009-02-07”,
                           updated_at: “2014-03-15”})
  @invoice3 = Invoice.new({id: 3,
                           customer_id: 2,
                           merchant_id: 12334753,
                           status: “pending”,
                           created_at: “2009-02-07”,
                           updated_at: “2014-03-15”})&lt;/p&gt;

&lt;p&gt;@invoices = [invoice1, invoice2, invoice3]
  @se       = SalesEngine.new&lt;/p&gt;

&lt;p&gt;@ir = InvoiceRepository.new(@invoices, se)
end
```&lt;/p&gt;

&lt;p&gt;Looking at a few of our tests it seemed that the repos generally took an array in their initialize, so it just became a matter of creating three or four instances of whatever the repo is supposed to hold, putting those into an array, and then passing that array to the repo. That put us in pretty much the same place as we were for our Items/Merchants testing, and we could just look to the top of the test to see what we were expecting.&lt;/p&gt;

&lt;h3 id=&quot;sales-enginesales-analyst&quot;&gt;Sales Engine/Sales Analyst&lt;/h3&gt;

&lt;p&gt;For Sales Engine and Sales Analyst we wanted to use actual data, but not all of it. We took the data and cut out some chunks (usually around 25 rows or so, sometimes more) that we could use to do our testing and put those into a test_data folder in our test folder. We then initialize SE and/or SA with references to the test data instead of the full data set.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby
def setup
  @se = SalesEngine.from_csv({
    :items         =&amp;gt; &quot;./test/test_data/items_stub.csv&quot;,
    :merchants     =&amp;gt; &quot;./test/test_data/merchants_stub.csv&quot;,
    :invoices      =&amp;gt; &quot;./test/test_data/invoices_stub.csv&quot;,
    :invoice_items =&amp;gt; &quot;./test/test_data/invoice_items_stub.csv&quot;,
    :transactions  =&amp;gt; &quot;./test/test_data/transactions_stub.csv&quot;,
    :customers     =&amp;gt; &quot;./test/test_data/customers_stub.csv&quot;
  })
end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This became a little tricky when Sales Analyst started to look for outliers that are two above the standard deviation. Pretty consistently we had to go in to tweak the data so that, for example, we had enough Sunday purchases to make sure that we didnt get an empty array when trying to find outliers.&lt;/p&gt;

&lt;h3 id=&quot;sales-enginesales-analyst-part-ii&quot;&gt;Sales Engine/Sales Analyst Part II&lt;/h3&gt;

&lt;p&gt;Iteration 3 had us building and analyzing more relationships between the data. It seemed like we were getting nonsense results because the real data that we pulled for Merchants or Invoices didn’t necessarily have any relationship to other real data that we pulled for Transactions or ItemInvoices (which makes sense since we were just going in and pulling random chunks of data). Here we decided to go with completely synthetic data, which Kris was able to create for us. In essence we were trying to craft small data sets that had straightforward relationships so that we could pretty quickly determine expected outcomes for our tests. This way we would know that if we had an InvoiceItem that had an invoice_id of 2, then we would also have an Invoice in our InvoiceRepo with an id of 2 to go along with it.&lt;/p&gt;

&lt;h3 id=&quot;full-data&quot;&gt;Full Data&lt;/h3&gt;

&lt;p&gt;Ultimately that synethetic data only got us part of the way there. I’m pretty convinced that in a real world situation we would be able to have some deeper level discussions to determine the expected relationships between these pieces and design our data accordingly (this could be a silly, silly dream!). Unfortunately, in our case we were learning about the data and its relationships at the same time we were designing our tests. We built synthetic data that made sense at one point in the process, then found ourselves having to change it based on a deeper understanding that we accrued later. This of course broke all of our already established tests. As we started to see this more often, we decided that using the actual data would help us avoid some of these challenges. As Horace warned, we ended up dreading the tests a little, since we knew they would take some time to run. Given more time, I believe we could establish synthetic data that reflected the complexities of the actual data with fewer lines, but with the project due, we made what I think is probably an appropriate compromise. We still used our synthetic data where possible, and hit the real data as needed, and I don’t even feel that bad about it.&lt;/p&gt;

&lt;p&gt;Maybe just a little.&lt;/p&gt;

&lt;p&gt;Listen, I’m not redoing my tests now, okay? That said, I think next time we’ll likely push synthetic data earlier, and try to get a more thorough understanding of the relationships/shape of the project. This should help to keep us from having to reconfigure the data and keep the testing cycle relatively painless. If nothing else this project taught me the value of being able to cycle through your tests and continue coding without having to wait for tests to pass. I promise to do better next time.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Mar 2016 10:01:46 -0600</pubDate>
        <link>http://s-espinosa.github.io/testing/2016/03/15/look-at-all-those-passing-tests.html</link>
        <guid isPermaLink="true">http://s-espinosa.github.io/testing/2016/03/15/look-at-all-those-passing-tests.html</guid>


        <category>testing</category>

      </item>

  </channel>
</rss>
